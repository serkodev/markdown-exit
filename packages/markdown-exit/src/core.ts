// Main parser class

import type { ParserOptions } from './parser'
import type { RenderOptions } from './renderer'
import type { Preset } from './types/preset'
import type { MarkdownExitEnv } from './types/shared'
import * as utils from './common/utils'
import { Parser } from './parser'
import cfg_commonmark from './presets/commonmark'
import cfg_default from './presets/default'
import cfg_zero from './presets/zero'
import { Renderer } from './renderer'

/**
 * MarkdownExit provides named presets as a convenience to quickly
 * enable/disable active syntax rules and options for common use cases.
 *
 * - ["commonmark"](https://github.com/serkodev/markdown-exit/tree/main/packages/markdown-exit/src/presets/commonmark.ts) -
 *   configures parser to strict [CommonMark](http://commonmark.org/) mode.
 * - [default](https://github.com/serkodev/markdown-exit/tree/main/packages/markdown-exit/src/presets/default.ts) -
 *   similar to GFM, used when no preset name given. Enables all available rules,
 *   but still without html, typographer & autolinker.
 * - ["zero"](https://github.com/serkodev/markdown-exit/tree/main/packages/markdown-exit/src/presets/zero.ts) -
 *   all rules disabled. Useful to quickly setup your config via `.enable()`.
 *   For example, when you need only `bold` and `italic` markup and nothing else.
 */
export type PresetName = 'default' | 'zero' | 'commonmark'

// not use `type =` for generate corrent typedoc
export interface MarkdownExitOptions extends ParserOptions, RenderOptions {}

const config: Record<string, Preset> = {
  default: cfg_default,
  zero: cfg_zero,
  commonmark: cfg_commonmark,
}

export type PluginSimple = (md: MarkdownExit) => void
export type PluginWithOptions<T = any> = (md: MarkdownExit, options?: T) => void
export type PluginWithParams = (md: MarkdownExit, ...params: any[]) => void

export class MarkdownExit extends Parser {
  /**
   * Instance of {@link Renderer}. Use it to modify output look. Or to add rendering
   * rules for new token types, generated by plugins.
   *
   * ##### Example
   *
   * ```javascript
   * function myToken(tokens, idx, options, env, self) {
   *   //...
   *   return result;
   * };
   *
   * md.renderer.rules['my_token'] = myToken
   * ```
   *
   * See {@link Renderer} docs and [source code](https://github.com/serkodev/markdown-exit/tree/main/packages/markdown-exit/src/renderer.ts).
   */
  renderer: Renderer = new Renderer()

  // Expose utils & helpers for easy acces from plugins

  /**
   * Assorted utility functions, useful to write plugins. See details
   * [here](https://github.com/serkodev/markdown-exit/tree/main/packages/markdown-exit/src/common/utils.ts).
   */
  utils: typeof utils = utils

  options: Required<MarkdownExitOptions> = { ...config.default.options }

  // Overloads for constructor
  constructor(options?: MarkdownExitOptions)
  constructor(presetName: PresetName, options?: MarkdownExitOptions)
  constructor(presetNameOrOptions?: PresetName | MarkdownExitOptions, options?: MarkdownExitOptions) {
    super()

    // normalize arguments
    const [presetName, opts]: [PresetName, MarkdownExitOptions?] = typeof presetNameOrOptions === 'string'
      ? [presetNameOrOptions, options]
      : ['default', presetNameOrOptions]

    this.configure(presetName)

    if (opts)
      this.set(opts)
  }

  /**
   * chainable*
   *
   * Set parser options (in the same format as in constructor). Probably, you
   * will never need it, but you can change options after constructor call.
   *
   * ##### Example
   *
   * ```javascript
   * md.set({ html: true, breaks: true })
   *   .set({ typographer: true });
   * ```
   *
   * __Note:__ To achieve the best possible performance, don't modify a
   * `markdown-exit` instance options on the fly. If you need multiple configurations
   * it's best to create multiple instances and initialize each with separate
   * config.
   */
  set(options: MarkdownExitOptions): this {
    utils.assign(this.options, options)
    return this
  }

  /**
   * chainable*, *internal*
   *
   * Batch load of all options and compenent settings. This is internal method,
   * and you probably will not need it. But if you with - see available presets
   * and data structure [here](https://github.com/serkodev/markdown-exit/tree/main/packages/markdown-exit/src/presets)
   *
   * We strongly recommend to use presets instead of direct config loads. That
   * will give better compatibility with next versions.
   */
  configure(presets: PresetName | Preset): this {
    if (typeof presets === 'string') {
      const presetName = presets
      presets = config[presetName]
      if (!presets)
        throw new Error(`Wrong \`markdown-exit\` preset "${presetName}", check name`)
    }

    if (!presets)
      throw new Error('Wrong `markdown-exit` preset, can\'t be empty')

    if (presets.options)
      this.set(presets.options)

    if (presets.components) {
      for (const name of Object.keys(presets.components) as (keyof typeof presets.components)[]) {
        const component = presets.components[name]
        if (component.rules) {
          this[name].ruler.enableOnly(component.rules)
        }
        if ((component as any).rules2) {
          (this[name] as any).ruler2?.enableOnly((component as any).rules2)
        }
      }
    }
    return this
  }

  /**
   * chainable*
   *
   * Enable list or rules. It will automatically find appropriate components,
   * containing rules with given names. If rule not found, and `ignoreInvalid`
   * not set - throws exception.
   *
   * ##### Example
   *
   * ```javascript
   * md.enable(['sub', 'sup'])
   *   .disable('smartquotes');
   * ```
   *
   * @param list rule name or list of rule names to enable
   * @param ignoreInvalid set `true` to ignore errors when rule not found.
   */
  enable(list: string | string[], ignoreInvalid?: boolean): this {
    let result: string[] = []

    if (!Array.isArray(list))
      list = [list]

    const chains = ['core', 'block', 'inline'] as const
    for (const chain of chains) {
      result = result.concat(this[chain].ruler.enable(list, true))
    }

    result = result.concat(this.inline.ruler2.enable(list, true))

    const missed = list.filter(name => !result.includes(name))

    if (missed.length && !ignoreInvalid) {
      throw new Error(`MarkdownExit. Failed to enable unknown rule(s): ${missed}`)
    }

    return this
  }

  /**
   * chainable*
   *
   * The same as {@link MarkdownExit.enable}, but turn specified rules off.
   *
   * @param list rule name or list of rule names to disable.
   * @param ignoreInvalid set `true` to ignore errors when rule not found.
   */
  disable(list: string | string[], ignoreInvalid?: boolean): this {
    let result: string[] = []

    if (!Array.isArray(list))
      list = [list]

    const chains = ['core', 'block', 'inline'] as const
    for (const chain of chains) {
      result = result.concat(this[chain].ruler.disable(list, true))
    }

    result = result.concat(this.inline.ruler2.disable(list, true))

    const missed = list.filter(name => !result.includes(name))

    if (missed.length && !ignoreInvalid) {
      throw new Error(`MarkdownExit. Failed to disable unknown rule(s): ${missed}`)
    }
    return this
  }

  /**
   * chainable*
   *
   * Load specified plugin with given params into current parser instance.
   * It's just a sugar to call `plugin(md, params)` with curring.
   *
   * ##### Example
   *
   * ```javascript
   * var iterator = require('markdown-it-for-inline');
   * md.use(iterator, 'foo_replace', 'text', function (tokens, idx) {
   *   tokens[idx].content = tokens[idx].content.replace(/foo/g, 'bar');
   * });
   * ```
   */
  use(plugin: PluginSimple): this
  use<T = any>(plugin: PluginWithOptions<T>, options?: T): this
  use(plugin: PluginWithParams, ...params: any[]): this
  use(plugin: PluginWithParams, ...params: any[]): this {
    plugin.apply(plugin, [this, ...params])
    return this
  }

  /**
   * Render markdown string into html. It does all magic for you :).
   *
   * `env` can be used to inject additional metadata (`{}` by default).
   * But you will not need it with high probability. See also comment
   * in {@link MarkdownExit.parse}.
   *
   * @param src source string
   * @param env environment sandbox
   */
  render(src: string, env: MarkdownExitEnv = {}): string {
    return this.renderer.render(this.parse(src, env), this.options, env)
  }

  /**
   * Async version of {@link MarkdownExit.render}. Runs all render rules in parallel
   * (Promise.all) and preserves output order.
   */
  renderAsync(src: string, env: MarkdownExitEnv = {}): Promise<string> {
    return this.renderer.renderAsync(this.parse(src, env), this.options, env)
  }

  /**
   * Similar to {@link MarkdownExit.render} but for single paragraph content. Result
   * will NOT be wrapped into `<p>` tags.
   *
   * @param src source string
   * @param env environment sandbox
   */
  renderInline(src: string, env: MarkdownExitEnv = {}): string {
    return this.renderer.render(this.parseInline(src, env), this.options, env)
  }

  /**
   * Async version of {@link MarkdownExit.renderInline}. Runs all render rules in parallel
   * (Promise.all) and preserves output order.
   */
  renderInlineAsync(src: string, env: MarkdownExitEnv = {}): Promise<string> {
    return this.renderer.renderAsync(this.parseInline(src, env), this.options, env)
  }
}

export function createMarkdownExit(options?: MarkdownExitOptions): MarkdownExit
export function createMarkdownExit(presetName: PresetName, options?: MarkdownExitOptions): MarkdownExit
export function createMarkdownExit(presetNameOrOptions?: any, options?: any): MarkdownExit {
  return new MarkdownExit(presetNameOrOptions, options)
}
